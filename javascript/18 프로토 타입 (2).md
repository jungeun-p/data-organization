# 18. 프로토 타입 (2)

## ✔️ 리터럴로 생성된 객체도 생성자 함수와 프로토타입이 있을까?

리터럴(`{}`)로 생성된 객체 또한 `prototype`이 존재한다. `**Object.prototype`을 프로토타입으로 갖는 빈 객체를 생성**하게 되는데, 다만 프로퍼티를 추가하는 처리 등의 세부 내용이 다르기 때문에, **Object 생성자 함수가 생성한 객체는 아니다. 단지 상속을 위해 프로토타입이 필요하기 때문에 가상적인 생성자 함수를 갖게 되는 것이다.** 결국 동일한 특성일 지니고 있어 ‘생성자 함수 = 리터럴로 생성된 객체를 생성한 함수’라 할 수도 있다. 

## ✔️ 프로토타입 생성 시점

프로토타입은 **생성자 함수와 더불어 생성**된다. **프로토타입과 생성자 함수는 언제나 쌍으로 존재**하기 때문이다. 

### ∙사용자 정의 생성자 함수&프로토타입 생성 시점

함수 선언문의 경우 런타임 이전에 평가되어, constructor는 **함수 객체를 생성하는 시점에 프로토타입도 더불어 생성**된다. (단, non-constructor의 경우 프로토타입이 생성되지 않는다.)

생성자 함수에 의해 생성된 `prototype`은 **오직 constructor 프로퍼티만을 지닌 객체이며,** 생성된 프로토타입의 `prototype`은 `Object.prototype`이다. 

### ∙빌트인 생성자 함수&프로토타입 생성 시점

빌트인 생성자 함수와 동시에 `prototype`이 생성된다. **전역 객체가 생성되는 시점**으로, **빌트인 생성자 함수의 prototype 프로퍼티에 바인딩**된다. 

## ✔️ 객체 생성 방식에 따른 프로토타입의 결정

객체 생성 방식에는 객체 리터럴, Object 생성자 함수, 생성자 함수, Object.create 메서드, 클래스(ES6) 등이 존재한다. 

### ∙객체 리터럴(`{}`)에 의해 생성된 객체의 프로토타입

추상 연산 **OrdinaryObjectCreate를 호출**하며, 전달되는 프로토 타입은 `Object.prototype` 이다. 생성된 객체는 constructor, hasOwnProperty 메서드가 없지만 프로토타입인 `Object.prototype`에서 **상속받아 사용** 가능하다. 

### ∙Object 생성자 함수에 의해 생성된 객체의 프로토타입

`Object.prototype`이 전달된다. 다만 객체 리터럴로 생성된 객체와는 프로퍼티 추가하는 방식의 차이점이 존재한다. 

### ∙생성자 함수에 의해 생성된 객체의 프로토타입

생성자 함수의 **prototype 프로퍼티에 바인딩 된 객체**다. 사용자 정의 생성자 함수와 생성된 `prototype`의 **프로퍼티는 constructor**뿐이다. 해당 `prototype`에 **프로퍼티나 메서드를 추가하여 자식 객체가 상속받을 수 있도록 처리**한다.