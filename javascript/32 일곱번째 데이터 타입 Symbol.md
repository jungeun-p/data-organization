# 32. 일곱번째 데이터 타입 Symbol

**변경 불가능한 원시 타입의 값.** 중복되지 않는 **유일무이한 값으로 이름 충돌 위험을 방지**한 **프로퍼티 키를 생성**하기 위해 사용한다. 

## ✔️ `Symbol` 생성

`Symbol()`함수를 통해 생성하며, 다른 값과 **중복되지 않는 유일무이한** 값이다. `**new` 연산자 없이 생성** 가능하며, 객체처럼 접근시 **암묵적으로 래퍼 객체를 생성**한다. `boolean` 타입만 암묵적 변환.

- `**Symbol.for()**`
    
    문자열을 키로 사용하여 전역 심벌 레지스트리(키와 심벌 값의 쌍들이 저장된 곳)에서 일치하는 **값을 검색**한다. 중복되지 않는 유일무이한 상수인 단 하나의 심벌 값을 생성하여 공유.
    
- `**Symbol.key()**`
    
    전역 심벌 레지스트리에서 저장된 **심벌 값의 키를 추출.** 
    

## ✔️ 프로퍼티/키

빈 문자열을 포함한 모든 문자열을 심벌 값으로 생성 가능하며, 동적으로도 생성(`[]` 사용)가능. 

## ✔️ 은닉

외부 노출이 불필요한 프로퍼티 은닉도 가능하다. `Object.etOwnPropertySymbols()` 메서드로 프로퍼티를 찾을 수 있다.

## ✔️ 표준 빌트인 객체 확장 가능

표준 빌트인 객체의 경우 직접 메서드 추가시 이름 중복의 위험이 있기 때문에 권장하지 않는다. 단, **심벌 값으로 키를 생성하여 확장할 경우 충돌 위험이 없다.** 

## ✔️ Well-knwon `Symbol`

기본 제공하는 빌트인 심벌 값. **이터러블**은 `Symbol.iterator`를 키로 지닌 메서드를 갖는다. 메서드 호출시 **이터레이터**를 반환하도록 규정된다. `Symbo.iterator`는 프로퍼티 키와 중복되지 않는다. 

### ∙일반 객체를 이터러블처럼 동작하기 바란다면?

`Symbol.iterator`를 키로 갖는 메서드를 객체에 추가하여 이터레이터를 반환하도록 구현한다. 

---

### ✍️

변경 불가한 원시 타입의 값으로 중복되지 않는 유일무이한 값으로 이름 충돌을 방지하며 프로퍼티 키를 생성하기 위해 사용된다. `new` 연산자 없이 생성 가능하며, 객체처럼 접근시 암묵적으로 래퍼 객체를 생성한다. `Symbol.for()`로 값을 검색하거나, `Symbol.key()`를 통해 키를 추출할 수 있으며 빈 문자열을 포함한 모든 문자열을 심벌값으로 생성이 가능하다. 프로퍼티 은닉도 가능하며, 표준 빌트인 객체 확장시 이름 충돌 위험이 없다. 

기본 제공되는 빌트인 심벌 값**(well-known `symbol`**)의 **이터러블**은 `Symbol.iterator`를 키로 지닌 메서드를 지니며 호출시 이터레이터를 반환한다.