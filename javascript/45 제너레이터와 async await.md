# 45. 제너레이터와 async/await

## ✔️ 제너레이터

: 코드 블록 실행 일시 중지 및 재개를 중재할 수 있는 특수 함수. 

함수 호출자에게 **함수 실행권을 양도(`yield`)**하며, **함수 상태를 주고 받는다.** **제너레이터 객체를 반환**하고, **이터러블인 동시에 이터레이터 리절트 객체(`value`, `done` 프로퍼티)를 반환하는 `next()`메서드를 소유한 이터레이터다.** **제너레이터 함수의 코드 블록을 실행**한다. 

이터러블 구현이 간단하고, 비동기 처리 또한 **~~프로미스 후속 처리 메서드~~ 없이도 결과 반환**이 가능.

### ∙ 사용법

- `**function***` 키워드로 선언한다. 하나 이상의 `yield` 표현식을 포함하며, 화살표 함수 및 생성자 함수로 생성 불가.

### ∙ 메서드

- `next()`
    
    실행 중지 및 재개. 호출 함수에게 제어권을 양도하여 함수 실행 및 재개 가능. 다음 메서드로 호출시 변수에 할당이 되고 완료 처리.
    
- `return()`
    
    제너레이터 실행 중지 및 표현식 결과(리절트 객체)를 함수 호출자에게 반환. 
    
- `throw()`

## ✔️ `async` / `await`

제너레이터보다 간단하고 가독성 있게 **비동기를 동기처럼 구현 가능**한 기능. **프로미스 기반**으로 동작, **후속 처리 메서드 없이도 동기처럼 프로미스 결과 반환**이 가능하다. 

```jsx
const foo = **async**() => {
	**try** {
		const res = **await** fethc(url);
		const data = **await** res.json();
	} **catch(e)** {
		console.log(e);
	}
}
```

### ∙ async

`async` 키워드로 정의시 **프로미스를 반환**한다. **암묵적으로 resolve하는 프로미스를 반환값**으로 처리. 단, 클래스의 `constructor` 메서드는 인스턴스를 반환하기 때문에 `async` 메서드가 될 수 없다.

### ∙ await

프로미스 앞에 `await` 키워드를 사용. 반드시 `async` 함수 내부에서 사용되며, 프로미스가 `settled` 상태까지 대기하다가 **완료시 `resolve`한 결과를 반환.** 

- 실행 중지 후, `settled` 상태가 되면 재개한다.
- `Promise.all()` 메서드를 통해 여러개의 비동기 함수를 한꺼번에 처리 가능.
- `await` 키워드를 각각 사용하여 비동기의 순차적 처리도 가능.

### ∙ error

비동기 함수의 콜백 함수를 호출한 것은 비동기 함수가 아니기에 `try-catch`문 사용이 어려우나, `async`/`await` 사용시 명시적 호출이 가능하여 `tray-catch`문 사용이 가능.