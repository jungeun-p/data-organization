# 26. 배열 (2) - 메서드

## ✔️ 배열 메서드

정적 메서드와 프로토타입 메서드로 나뉜다. 부수효과가 없는 메서드를 사용하는 것이 상태를 불변으로 관리하기 좋다. 

### ∙정적 메서드

- `Array.isArray()`
    
    전달된 인수가 배열인지 아닌지를 판별하여 `boolean` 타입 반환.
    

### ∙프로토타입 메서드

- `Array.prototype.indexOf()`
    
    특정 요소 검수를 위해 인수로 전달된 배열의 요소를 검색하여 `index` 반환. 특정 요소가 포함되어 있는지 검수 하는 ES7의 `**Array.prototype.includes()**` 메서드가 가독성이 더 좋다.
    
- **(부)**`Array.prototype.push()`
    
    전달된 인수를 **배열 마지막 요소로 추가**하여 **변경된 `length` 프로퍼티를 반환**한다. 원본 배열을 직접 수정하기 때문에 부수효과가 일어나게 되어 되도록 **spread 문법으로 대체**하는 것이 좋다.
    
- `Array.prototype.pop()`
    
    **배열의 마지막 요소를 제거한 후 반환.** **push()와 스택(stack)**을 동시에 구현.
    
- **(부)**`Array.prototype.unshift()`
    
    전달된 인수를 **배열의 선두에 추가하고 변경된 `length`를 반환**. `push()` 메서드와 마찬가지로 상태가 변경되는 부수효과가 일어난다. 
    
- `Array.prototype.shift()`
    
    **배열의 첫 번째 요소를 제거한 후 반환.** **push()와 큐(queue)**를 동시에 구현.
    

---

- `**Array.prototype.concat()**`
    
    전달된 인수를 **마지막 요소로 추가한 후 배열 반환.** 부수효과 없이 **불변으로 상태 관리**가 가능하다. 스프레드 문법 대체 사용. 
    
- **(부)**`Array.prototype.splice(1.인덱스 시작, 2.제거할 요소 갯수, 3.추가할 요소)`
    
    배열의 **특정 index로 요소를 추가 및 삭제**가 가능하며 **원본 배열을 직접 변경**한다. 
    
- `**Array.prototype.slice(1.인덱스 시작, 2.인덱스 이전까지)**`
    
    **범위의 요소를 복사하여 새로운 배열로 반환.** 원본 배열은 변경되지 않고, **shallow copy를 통해 불변으로 상태**가 관리된다. 객체는 다르지만 **참조값은 동일.** 
    
- `Array.prototype.join()`
    
    **모든 요소를 문자열로 변환**하여 **전달받은 인수를 구분자로 연결한 문자열을 반환**한다. 생략시 default는 콤마(`,`)
    
- **(부)**`Array.prototype.reverse()`
    
    원본 배열의 순서를 반대로 뒤집는다. 원본 배열이 변경되는 부수효과가 일어난다. 
    
- **(부)**`Array.prototype.fill(1.요소, 2.시작할 인덱스, 3.멈출 인덱스 전까지)`
    
    인수로 전달 받은 값을 **배열의 처음부터 끝까지 요소로 채운다.** 원본 배열이 변경되는 부수효과가 일어나며, 하나의 값만 추가할 수 있지만 `Array.from()` 메서드 사용시 두번째 인수로 콜백함수를 전달하여 요소값을 만들며 배열을 채울 수 있다.
    
- `Array.prototype.includes(1.요소, 2.시작할 인덱스)`
    
    배열 내의 특정 요소를 확인하여 **포함 여부에 따라 `boolean` 타입을 반환**한다.
    
- `Array.prototype.flat()`
    
    전달된 인수(깊이)만큼 **재귀적으로 배열을 평탄화**한다. default는 1이며, Infinity로 지정시 모두 평탄화.