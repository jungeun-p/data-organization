# 12. 스코프

식별자는 **선언된 위치에 따라** 자신을 참조할 수 있는 유효 범위가 결정되는데, 이를 스코프라고 한다. **식별자가 유효한 범위**를 의미하며 자바스크립트 엔진은 코드 실행시 문맥을 고려하여 식별자를 결정한다. 

**네임 스페이스**를 통해 다른 스코프와 경계를 두어 동일한 식별자 충돌을 방지한다. 

### ∙var와 let&const의 차이

var 키워드는 동일한 스코프 내에서 중복 선언이 허용되어 변수값이 재할당 되지만, let & const 키워드는 스코프 내의 중복 선언을 허용하지 않는 차이점이 있다. 

## ✔️ 전역과 지역

코드는 바깥 영역의 **전역**과, 함수 몸체 내부의 **지역**으로 나뉘어지며 스코프와 변수도 동일하다. 자신이 정의된 위치에 따라 스코프가 결정되며 **스코프 체인**을 통해 참조할 변수를 검색한다. 

## ✔️ 스코프 체인

- **중첩 함수**

함수 내부에 함수가 정의된 함수를 의미하며, 중첩된 함수는 지역 스코프도 함께 중첩이 가능하며 이를 통해 계층적 구조를 갖게 된다. ⇒ 외부 함수의 지역 스코프는 내부 함수의 상위 스코프가 된다.

**계층적으로 연결된 스코프.** **실행 컨텍스트의 렉시컬 환경을 단방향으로 연결**한 것을 의미한다. 스코프 체인을 통해 하위에서 상위 스코프로 단방향으로 변수를 탐색한다.  

### ∙실행 컨텍스트와 렉시컬 환경은 무엇일까?

- **렉시컬 환경** 코드의 문맥으로, ****코드가 어디서 실행되고 주변에 어떤 코드가 있는지를 의미.
- **실행 컨텍스트** 렉시컬 환경을 구현한 것. 모든 코드는 실행 컨텍스트에서 평가되고 실행된다.

자바스크립트 엔진은 **실행 컨텍스트를 통해 렉시컬 환경을 생성**하는데, 런타임 이전에 변수 선언이 실행되면 렉시컬 환경에 key로 등록되어 변수가 할당된다. 

결국 스코프는 변수 검색 뿐만 아니라 **식별자를 검색하는 규칙**이라는 표현이 더 맞다. 

## ✔️ 스코프 종류

### ∙함수 레벨 스코프(`var`)

**함수 코드 블록**만을 지역 스코프로 사용하며, 블록 안에 선언되어도 전역 변수가 되어 재할당이 되는 부수효과가 나타난다. 

### ∙블록 레벨 스코프(`let`, `const`, `if`, `for`, while, `try/catch`)

**블록 레벨 스코프**만을 지역 스코프로 인정한다. 

### ∙렉시컬 스코프

함수 정의가 평가되는 시점에 정적으로 결정된 스코프로, 렉시컬 스코프를 통해 자신이 정의된 스코프가 곧 상위 스코프로 결정된다. 함수가 호출되는 곳과 상관없이 함수가 정의되며 결정된 상위 스코프를 참조(클로저)한다. 

## ✍️ 정리

식별자는 자신이 선언된 위치에 따라 유효 범위가 결정되는데 이를 **스코프**라 한다. 코드는 전역과 지역으로 나뉘어지는데 이는 변수나 스코프도 동일하게 적용된다. 즉 **자신이 정의된 위치에 따라 스코프가 결정된다.**

중첩 함수를 통해 지역 **스코프도 중첩**이 가능한데, 이때 외부 함수는 내부 함수의 상위 스코프가 된다. 이렇게 **계층적으로 연결되어 실행 컨텍스트의 렉시컬 환경이 단방향으로 연결되어 스코프 체인**이 생성되고 하위에서 상위 스코프 단방향으로 탐색한다.

자바스크립트 엔진은 실행 컨텍스트를 통해 렉시컬 환경을 생성하고 코드의 문맥을 통해 변수를 탐색한다. 즉, 모든 코드는 실행 컨텍스트에서 평가되고 실행된다. 

스코프는 함수 레벨 스코프, 블록 레벨 스코프, 렉시컬 스코프로 나뉘어진다. **함수 레벨 스코프는 함수 코드 블록만을 지역 스코프**로 사용하며, 블록 레벨 안에 선언 되어도 전역 변수가 되어 재할당이 되는 부수효과가 일어난다. **블록 레벨 스코프는 블록 레벨 스코프만을 지역 스코프**로 인정한다. **렉시컬 스코프는 함수가 정의되는 시점에서 정적으로 결정된 스코프**로, 자신이 정의된 곳이 곧 상위 스코프가 된다. 함수 호출되는 곳과 별개로 결정되었던 상위 스코프를 참조(클로저)한다.