# 중간 점검 🆀&🄰 (3)

## 𝐐. 프로토타입

### 🆀 객체지향 프로그래밍이란?

**🄰** 객체는 **상태를 나타내는 프로퍼티**, **상태를 조작하는 메서드**를 **하나의 단위로 묶은 복합적인 자료구조**이다. 이러한 **객체의 집합으로 프로그램을 표현**하려는 **프로그래밍 패러다임**이라 할 수 있다.

**자바스크립트는 프로토타입 기반의 객체 지향 프로그래밍 언어**이다. 클래스 기반의 객체 지향 프로그래밍 언어보다, 훨씬 효율적이고 객체지향적인 성향을 띤다.

### 🆀 프로토타입이란?

**🄰** **상속을 구현하며 추상화**를 처리를 통해 중복을 제거합니다. 단 **하나의 메서드를 모든 인스턴스가 공유**하며, 생성자 함수가 생성한 모든 인스턴스는 **자신의 프로토타입, 생성자 함수의 프로토타입의 모든 프로퍼티와 메서드를 상속**받을 수 있습니니다.

여기서 상속은, 프로퍼티와 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 개념을 뜻합니다. 

### 🆀 프로토타입 객체란?

**🄰 객체간의 상속을 구현**하기 위해 사용된다. 상속받는 **하위 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 사용**이 가능하며, 모든 객체는 **`[[prototype]]`** 내부 슬롯을 지닌다. 프로토타입은 객체 생성 방식에 따라 결정되는데, **객체는 하나의 프로토타입**을 지니며 **생성자 함수와 연결**되어 있다. 생성자 함수의 **prototype 프로퍼티**와, 생성자 함수의 프로토타입의 **constructor** 프로퍼티는 **상호 연결**되어 접근이 가능하다.

### 🆀 __proto__ 접근자 프로퍼티는 무엇일까?

**🄰 생성자 함수의 프로토타입이 지닌 프로퍼티**. 자신의 프로토타입의 **`[[Prototype]]` 내부슬롯이 가리키는 프로토타입에 간접적으로 접근**이 가능하다. **단방향으로 구성**되어 **상속만 가능**하게 되어있으며 **프로토타입 체인 생성을 방지**한다. 

### 🆀 생성자 함수 객체의 prototype 프로퍼티는 무엇일까?

**🄰** 함수 객체만이 소유하는 prototype 프로퍼티로, **생성자 함수가 생성할 인스턴스의 prototype을 가리킨다.** 단, 화살표 함수를 비롯한 non-constructor는 프로토타입 생성이 불가하다. 

결국 **__proto__ 접근자 프로퍼티**와, **함수 객체만이 지닌 prototype 프로퍼티**는 사용 목적은 달라도 **동일한 prototype을 가리**키게 된다. 

### 🆀 프로토타입의 constructor 프로퍼티는 무엇일까?

**🄰** **모든 프로토타입은 constructor 프로퍼티**를 지닌다. **자신을 참조하는 생성자 함수를 가리**키며, 해당 연결은 함수 객체가 생성될 때 자동으로 이뤄진다.

---

### 🆀 리터럴(`{}`)로 생성된 객체의 생성자 함수와 프로토타입

**🄰** 리터럴로 생성된 객체도 **프로토타입이 존재**한다. `Object.prototype`을 프로토타입으로 갖는 빈 객체를 생성한다. 단, Object 생성자 함수가 생성한 객체가 아닌 **단순 상속을 위해 프로토타입이 필요**하기 때문에 **가상의 생성자 함수(Object)**를 갖게 되는 것이다. 생성자 함수는 곧 리터럴로 생성된 객체를 생성한 함수라 할 수 있다. 

### 🆀 프로토타입의 생성 시점은?

**🄰** **생성자 함수와 더불어 생성**된다. 프로토타입과 생성자 함수는 **언제나 쌍으로 존재**한다.

사용자 정의 생성자 함수의 경우, 함수 선언문은 런타임 이전에 평가되어 **constructor 함수 객체를 생성하는 시점에 프로토타입이 더불어 생성**(non-constructor X)된다. 오직 constructor 프로퍼티만을 지닌 객체이며, 프로토타입의 prototype은 `Object.prototype`이다. 

빌트인 생성자 함수는 **전역 객체가 생성되는 시점**으로, **빌트인 생성자 함수의 prototype 프로퍼티에 동시에 바인딩** 된다.  

### 🆀 객체 생성 방식에 따른 프로토타입은 어떻게 다를까?

**🄰** 객체 리터럴(`{}`)의 프로토타입은 `Object.prototype`이다. 생성된 객체는 `constructor` / `hasOwnProperty` **메서드가 부재**하지만, **`Object.prototype`에서 상속 받아 사용 가능.** 

Object 생성자 함수의 프로토타입은 `Object.prototype`이다.객체 리터럴과 동일하지만, 프로퍼티 추가하는 방식의 차이점이 존재한다.

생성자 함수의 프로토타입은 생성자 함수에 존재하는 **prototype** **프로퍼티에 바인딩 된 객체**다. 생성된 프로토타입의 프로퍼티는 constructor뿐이며, 프로토타입에 프로퍼티 및 메서드를 추가하여 하위 객체가 상속받을 수 있도록 처리한다.

---

### 🆀 프로토타입 체인이란?

**🄰** 객체에 접근할 **프로퍼티 검색 시,** **내부 슬롯에 바인딩 된 프로토타입으로 이동**하여 **메서드를 서치**하게 되는데 이를 **프로토타입 체인**이라 한다. **`Object.prototype`은 체인의 종점**이며, 상속과 프로퍼티를 위한 일종의 메커니즘이다.

예를 들어 생성자 함수의 경우, 프로토타입이 `Object.prototype` 이기도 하여 `hasOwnProperty` 메서드 호출이 가능하며 프로토타입의 프로토타입은 `Object.prototype` 이다. 

### 🆀 프로토타입 체인과 스코프 체인의 차이점은?

**🄰** 스코프 체인은 **식별자를 검색**하기 위한 메커니즘이며, 프로토타입 체인은 **프로퍼티를 검색**한다는 차이점이 존재한다. 

### 🆀 오버라이딩과 오버 로딩은 무엇일까?

**🄰** 오버라이딩은 상위 클래스가 지닌 메서드를 **하위 클래스가 재정의하여 사용하는 방식**이며, 오버 로딩은 함수의 이름은 동일하나 **매개변수에 의해 메서드를 구별하여 호출**하는 방식이다. 

### 🆀 프로퍼티 섀도잉은 무엇일까?

**🄰** 동일한 이름의 프로퍼티라면 **인스턴스가 우선**이다. **인스턴스 메서드가 프로토타입 메서드를 오버라이딩(하위 클래스가 재정의)함으로써 가려지는 것**을 **프로퍼티 섀도잉**이라 한다. 메서드 또한 **인스턴스가 우선적으로 삭제**된다. **하위 객체로** **`get`**은 가능하지만, **`set`은 프로토타입 프로퍼티에 접근**해야 한다. 

### 🆀 프로토타입은 교체가 가능할까?

**🄰** 생성자 함수 또는 인스턴스를 통해 동적으로 변경 가능하다. 

사용자에 의해 생성된 생성자 함수의 경우, constructor 프로퍼티가 부재함으로 **생성자 함수의 프로토타입에 직접 프로퍼티(consructor)를 추가**한다. → **생성할 인스턴스의 프로토타입이 교체**

인스턴스로 교체할 경우, **__proto__** 접근자 프로퍼티를 통해 가능하다. 즉, **이미 생성된 객체의 프로토타입을 교체**하는 것이다. 

**인스턴스에 의한 프로토타입 교체**는 **constructor 프로퍼티와 연결이 끊어**지게 되어 더이상 **생성자 함수를 가리키게 되지 않게** 된다. 메서드를 통해 프로토타입과 연결 시키거나 직접 교체하기 보다는 **클래스를 통해 직관적인 상속 관계를 구현**하는 것을 권장한다. 

### 🆀 `객체 instanceof 생성자 함수` 연산자는 무엇일까?

**🄰** 프로토타입의 constructor 프로퍼티 → 생성자 함수가 아닌, **생성자 함수의 prototype 프로퍼티 → 바인딩 된 객체가 프로토타입 체인상의 존재 여부를 확인**하는 **연산자**다. **`boolean` 값을 반환**하며, constructor 프로퍼티와 생성자 함수간의 연결보다, **객체가 상속받은 prototype 프로퍼티 → 프로토타입의 연결**이 유지된다면 문제가 없다.

---

### 🆀 프로토타입을 직접 상속하는 방법은 무엇이 있을까?

**🄰** `Object.create()` 메서드 혹은 **__proto__**접근자 프로퍼티로 직접 상속 구현이 가능하다. 

`Object.create(지정할 프토토타입, 생설할 객체의 키와 디스크립터 객체로 이뤄진 객체)`를 통해 명시적으로 프로토타입을 지정하여 객체 생성 후 직접적인 상속 구현이 가능하다. 단, Object.prototype은 모든 프로토타입 체인의 종점이므로, 객체를 생성할 가능성이 존재하여 빌트인 메서드는 간접 호출을 권장한다.

위의 방식보다 **__proto__**접근자 프로퍼티를 통해 간단하고 동일한 직접 상속 구현이 가능하다. 

```jsx
const object = {
	y: 20,
	__proto__: myProto // 프로토타입 상속
}
```

### 🆀 정적 프로퍼티와 메서드는 무엇일까?

**🄰** 별도의 인스턴스 생성 없이 **생성자 함수만으로 참조/호출이 가능한 프로퍼티와 메서드**다. **프로토타입 체인에 속하지 않아, 생성한 인스턴스로 참조/호출이 불가.**

☝️) **`Object.create`**는 __정적 메서드__, **`Object.prototype.hasOwnProperty`**는 생성자 함수의 __프로토타입 메서드__ 이다.

인스턴스 생성 없이도 프로토타입 메서드 호출이 가능하며, 이때 `this`는 **인스턴스를 가리킨다.**

### 🆀 프로퍼티 존재 유무를 어떻게 확인할까?

**🄰** **`key in object`**연산자(프로퍼티 존재 유무를 boolean 값으로 반환)와, **`Reflect.has(object, key)`** 메서드를 통해 확인이 가능하다.

**`Object.prototype.hasOwnProperty(key)`** 메서드를 통해 프로퍼티 존재 유무 확인이 가능하다. **객체 고유의 프로퍼티 키 ⇒ true**, **상속 받는 프로토타입의 프로퍼티 ⇒ false**를 반환한다.

### 🆀 프로퍼티를 열거하는 방법은 무엇이 있을까?

🄰 **`for(key in 객체){key...}`** 문을 통해 객체의 모든 프로퍼티를 순회하며 열거할 수 있다. Symbol이나 toString, Object.prototype은 제외되며 객체의 프로토타입 체인상에 존재하는 프로퍼티 중 [[Enumerable]] 값이 true인 값만 순회하며 열거. 단, 별도로 프로퍼티 존재 유무 추가 확인이 필요하다. 배열은 for, forEach, for…of 메서드를 권장. 

**`Object.keys/values/entires**(obj)` 자신의 프로퍼티인지 추가 확인을 동시에 처리** 해주는 메서드로 **사용이 권장**된다. 순서대로 **열거 가능한 키/값/키와 값의 쌍의** **배열을 담아 반환**한다.

```jsx
Object.entries(person)
	.forEach(([key, value])=>console.log(key, value))
```

### ⇒ 자바스크립트는 프로토타입 기반의 객체지향 프로그래밍 언어이다.

---

### 🆀 strict mode란 무엇일까?

**🄰** **엄격한 문법 체크**로 코드에 대한 **명시적 에러를 발생.** ⑴선언하지 않은 변수를 참조하거나, ⑵delete 연산자로 삭제하거나, ⑶매개변수 이름이 중복되거나, ⑷with문 사용시 에러를 발생. **즉시 실행 함수로 감쓴 스크립트 단위**로 적용.

---

## 𝐐. 빌트인 객체

전역 객체는 **빌트인 객체/호스트 객체/사용자 정의 객체**로 분류된다.

### 🆀 전역 객체는 무엇일까?

**🄰** 코드 실행 이전 단계에서 **자바스크립트 엔진에 의해 먼저 생성되는 특수한 객체**로, 구조상 **표준 빌트인 객체/호스트 객체를 프로퍼티로 소유하는 최상의 객체**이다. 브라우저 환경에서는 window, node.js 환경에서 global이라 표현한다. 

`var` 키워드 사용시 전역 변수 및 함수도 전역 객체의 프로퍼티가 된다. ↔ 블록 레벨 스코프인 `let`과 `const`로 선언한 변수는 전역 객체의 프로퍼티가 될 수 없다.

### 🆀 표준 빌트인 객체란 무엇일까?

**🄰** 자바스크립트는 약 40여개의 표준 빌트인 객체를 제공한다. 

생성자 함수인 표준 빌트인 객체는 프로토타입 메서드, 정적 메서드를 제공하고 생성한 인스턴스의 프로토타입(`생성자함수.prototype`)은 생성자 함수의 **prototype** 프로퍼티에 바인딩 된 객체다. (`String`(생성자 함수)의 **prototype** 프로퍼티 → `생성자 함수.prototype`)

생성자 함수가 아닌 표준 빌트인 객체(Math, Reflect, JSON)는 정적 메서드만 제공.

### 🆀 표준 빌트인 생성자 함수는 왜 존재할까?(원시값과 래퍼객체)

**🄰** **원시값에 객체처럼 접근**할 때, 자바스크립트 엔진은 **원시값을 일시적으로 연관된 객체를 생성**하여 프로퍼티 접근(`str.length`), 혹은 메서드 호출(`str.toUppercase()`) 뒤 원시값으로 되돌린다. 이때 생성되는 임시 객체를 **래퍼 객체**라고 한다.

즉, 표준 빌트인 생성자 함수는 **별다른 인스턴스를 생성할 필요가 없다.**

### 🆀 빌트인 전역 프로퍼티/전역 함수는 무엇인가?

**🄰** 전역 객체의 프로퍼티이다. 무한대를 나타내는 숫자값 **Infinity**, 숫자가 아닌 숫자값 **NaN**, 원시 타입인 **undefined**가 있다. 

전역 함수는 전역에서 호출할 수 있는 전역 객체의 메서드이다. `eval()` (문자열을 인수로 전달하여 값을 생성), `isFinite()` (정상적 유한수를 판별하여 boolean 값 반환), `isNaN()` (NaN을 판별하여 boolean 값 반환), `parseFloat()` (문자열 인수 → 실수로 해석 반환), `parseInt()` (문자열 인수 → 정수로 해석하여 반환), `encode/decodeURI()` (문자열을 이스케이프 처리를 위해 인코딩/인코딩 URI를 디코딩), `encode/decodeURIComponent()` (쿼리 스트링 구분자까지 포함한 URI 구성 요소를 인코딩/디코딩)등이 있다.

### 🆀 암묵적 전역은 어떻게 일어날까?

**🄰** **선언하지 않은 식별자에 값을 할당**하면 **전역 객체의 프로퍼티**가 된다. 예로 `y=20`이 **`window**.y=20` 동적으로 프로퍼티를 생성**하는데, 이를 **암묵적 전역**이라 한다. 단, 전역 객체 프로퍼티일 뿐 **전역 변수가 아니기에 호이스팅이 일어나지 않으며** **`delete`(전역 변수 삭제 불가)로도 삭제**가 가능하다.

---

## 𝐐. this

### 🆀 `this` keyword란?

**🄰** 자신이 속한 객체, 혹은 자신이 생성할 인스턴스를 가리키는 **자기 참조 변수**이다. 프로퍼티 또는 메서드 참조가 가능하며, **`this` 바인딩은 함수 호출 방식(invoke)**에 의해 **동적으로 결정**된다. 

결국 **객체의 프로퍼티나 메서드 참조를 위해 존재**하며, 객체 내의 메서드 혹은 생성자 함수에만 의미가 있으며 **일반 함수에선 `this`를 사용할 필요가 없다.**  

### 🆀 this가 존재하는 이유는?

**🄰** 메서드는 **자신이 속한 객체의 식별자를 참조** 해야 하며, 생성자 함수 정의 시점에선 **생성할 인스턴스가 부재하여 가리키는 식별자를 알 수 없기 때문**이다. 이때 자신이 속한 객체, 혹은 생성할 인스턴스를 가리킬 특수한 식별자가 `this`다.

### 🆀 함수 호출 방식에 따른 `this` 바인딩은 어떻게 다를까?

**🄰** this 바인딩은 함수 호출 방식에 따라 동적으로 결정되며, 렉시컬 스코프는 함수 객체가 생성되는 시점에서 상위 스코프를 결정하기 때문에 함수 호출 시점에서 바인딩 된다. 

일반 함수 **일반 함수 내부의 this는 전역 객체(window)**를 가리킨다. 객체 생성 함수가 아닌 이상, 의미가 없으며 중첩 함수나 콜백 함수의 경우에도 전역 객체로 바인딩 되어 화살표 함수로 상위 스코프 this 바인딩 처리로 보완 가능하다. 

메서드 **메서드를 호출한 객체에 바인딩** 된다.

생성자 함수 **생성자 함수가 생성할 인스턴스**를 가리킨다.

### 🆀 Function.prototype의 `apply/call/bind()`메서드에 의한 간접 호출의 `this` 바인딩은?

**🄰** **함수에 전달되는 인수에 의해 결정**된다. `apply()` 함수는 **호출 없이** **`this` 객체만 전달**하며, **콜백 함수 → 일반 함수로 호출 될 때 바인딩** 처리를 한다. `call()`/`bind()` 함수는 **`this` 객체를 전달하며 함수를 호출**한다.

---

## 𝐐. 실행 컨텍스트

### 🆀 실행 컨텍스트란 무엇일까?

**🄰** **소스 코드 평가 및 실행에 필요한** **환경이자,** **실행 결과를 관리하는 영역**입니다. 실행 컨텍스트 스택과, 렉시컬 환경으로 구성되어 있다. 

### 🆀 실행 컨텍스트 스택과 렉시컬 환경이란?

**🄰** **실행 컨텍스트 스택**은 컨텍스트가 **생성된 순서대로 구성된 Stack 자료구조**로, **코드의 실행 순서를 관리**하며 **소스 코드 평가 및 실행 완료시 pop되어 제거**된다. 현재 실행중인 실행 컨텍스트가 계층 구조상 최상위. 

**렉시컬 환경**은 **실행 컨텍스트를 구성하는 컴포넌트**로, **식별자와 바인딩 된 값**, **상위 스코프에 대한 참조가 기록된 자료구조**이다. 

### 🆀 소스 코드가 어떻게 평가되고 실행될까?

**🄰** 소스 코드는 전역, 함수, eval, 모듈 코드로 나뉘어지며 각각의 실행 컨텍스트가 생성된다. 

**소스코드 평가**시, 런타임 이전에 **⑴실행 컨텍스트가 생성**되어 선언문의 **⑵식별자를 key로 스코프에 등록**된다. **소스 코드 실행**시, 런타임 이후, 등록된 변수 및 함수에 **⑴값이 할당**되어 **⑵실행 결과를 등록**한다.

### 🆀 실행 컨텍스트의 역할은 무엇일까?

**🄰** 선언된 **식별자를 스코프에 등록**하여 구분하고, **상태 변화를 관리**한다. 중첩 관계의 경우 **스코프 체인을 생성하여 식별자를 검색**하고 **코드 순서 변경 및 조율을 처리**한다.

### 🆀 실행 컨텍스트 생성 및 식별자 검색 과정은 어떻게 될까?

**🄰** 전역 코드 평가 이전에 전역 객체가 생성된다. 이후 전역/함수/중첩 코드의 평가 → 실행 → 종료 순서로 진행된다.

```jsx
**소스 코드 평가**
1. 환경 레코드 / 외부 렉시컬 환경에 대한 참조
2. 실행 컨텍스트, 렉시컬 환경 생성
```

**✔️ 전역 코드**

- **전역 소스 코드 평가**

`전역 실행 컨텍스트가 생성 → 실행 컨텍스트 스택에 푸시 → 전역 렉시컬 환경 생성`된다. 이때, **전역 환경 레코드**와, **외부 렉시컬 환경**이라는 두 개의 컴포넌트에 대한 참조로 구성된다. 

**전역 환경 레코드**는 선언과 초기화가 동시에 진행되어 참조 가능한 것들로 구성(var로 선언된 전역 변수, 전역 함수, 호이스팅)된 **⑴객체 환경 레코드**와, 선언 이전에 접근이 불가능(let, const로 선언된 변수 및 블록 레벨 스코프)한 **⑵선언적 환경 레코드**, 전역 객체를 가리키는 **⑶this 바인딩**(전역 환경 레코드에만 존재)으로 구성 되어있다.

**외부 렉시컬 환경**은 자신이 최상위 스코프이기 때문에 `null`

- **전역 소스 코드 실행**

런타임 이후, **할당문이 실행**되어 값이 할당된다. **실행 컨텍스트** 내부에 선언된 **식별자를 검색하고 스코프 체인을 통해 스코프를 검색**한다. 

**✔️ 함수 코드**

- **함수 소스 코드 평가**

`함수 코드 호출시 전역 소스 코드 실행 중단 → 함수 내부로 이동 → 함수 소스 코드 평가 -> 함수 실행 컨텍스트 생성 → 렉시컬 환경 생성 → 실행 컨텍스트 스택에 푸시` 이때 **함수 환경 레코드**와, **렉시컬 환경**이 생성되어 컨텍스트에 바인딩 된다. 

**함수 환경 레코드**는 **⑴매개변수 객체**나, 함수 내부에 **⑵선언된 지역 변수 및 중첩 함수**, **⑶this 바인딩**(함수 환경 레코드 내부 슬롯, 일반 함수의 경우 전역 객체)으로 구성된다.

**렉시컬 환경** **함수가 정의된 시점**(전역 실행 컨텍스트에서 실행중인 실행 컨텍스트의 렉시컬 환경)이 **참조**된다. 즉, **함수는** 호출이 아닌 **정의 및 평가된 시점에서 상위 스코프가 결정**된다 ⇒ **클로저**

- **함수 소스 코드 실행**

**매개변수에 인수**가, **지역 변수에 값이 할당**된다. 중첩 함수 호출시 실행중인 실행 컨텍스트에서 식별자를 검색한다. 

**✔️ 중첩 함수 코드**

- 중첩 함수 소스 코드 평가

`중첩 함수 코드 호출시 함수 코드 실행 중단 → 중첩 함수 코드 내부로 이동 → 중첩 함수 코드 평가 → 중첩 함수 실행 컨텍스트/렉시컬 환경 생성 → 실행 컨텍스트 스택 푸시` 이때 **중첩 함수 환경 레코드**, **외부 레시컬 환경에 대한 참조**로 구성된다. 

- **중첩 함수 소스 코드 실행**

소스 코드 실행시 **매개변수, 지역변수에 값이 할당**된다. 예를 들어, `console.log`라는 메서드에서 `console`이라는 식별자를 렉시컬 환경에서 검색 → `log`라는 메서드를 검색 → 표현식 평가 후 값 생성시 해당 값을 `console.log`라는 메서드에 전달 → 호출을 완료하는 순서다. 

- **중첩 함수 소스 코드 종료**

실행 종료시 **실행 컨텍스트 스택**에서 **pop 되어 제거**된다. 단, 누군가가 참조하는 중이라면 소멸되지 않는다. 

**✔️ 전역/함수 코드**

- **함수 소스 코드 종료**

**실행 컨텍스트 스택에서 pop 되어 제거**된다. 

- **전역 소스 코드 종료**

**실행 컨텍스트 스택에서 pop 되어 제거**된다. 

### 🆀 실행 컨텍스트와 블록 레벨 스코프의 관계는?

**🄰** 블록 레벨 스코프는 **`let`, `const`로 선언된 변수**로 생성된다. 전역 환경 레코드에선 **선언적 환경 레코드**를 갖는 렉시컬 환경을 생성하며 교체한다. 

블록문 실행 이전, 종류 이후 전역 렉시컬 환경을 가리켰다가 되돌린다.

---

## 𝐐. 클로저

### 🆀 클로저란 무엇일까?

**🄰** **함수와, 해당 함수가 선언된 렉시컬 환경과의 조합**으로, 함수형 프로그래밍의 특성 중 하나다. 

### 🆀 렉시컬 스코프는 무엇일까?

**🄰** 함수 소스 코드 평가 중, **함수 실행 컨텍스트 생성** 후 **외부 렉시컬 환경에 대한 참조에 저장된 참조**값. 자신이 정의된 환경, 즉 **상위 스코프**를 뜻한다. 

### 🆀 렉시컬 스코프는 어떻게 생성될까?

**🄰** 함수 객체가 생성될 때, 자신이 정의된 환경(**전역 실행 컨텍스트의 렉시컬 환경**)의 참조를 `**[[Environment]]` 내부 슬롯에 저장**한다. 함수 소스 코드 평가시 생성된 **함수 실행 컨텍스트의 외부 렉시컬 환경에 대한 참조**에 **내부 슬롯에 저장된 렉시컬 스코프가 할당**된다. 

### 🆀 내부 슬롯은 현재 진행중인 (전역)실행 컨텍스트의 렉시컬 환경을 가리킬까?

**🄰** 그렇다! 함수 객체 생성 시점에 실행중인 **실행 컨텍스트(전역 실행 컨텍스트)가 최상위 실행 컨텍스트**다.

### 🆀 상위 스코프는 어떤 시점에 결정될까?

**🄰** **함수가 정의되는 시점**(전역 실행 컨텍스트)에서 스코프가 결정된다. **함수 실행 컨텍스트의 외부 렉시컬 환경에 대한 참조**는, **전역 실행 컨텍스트에서 생성된 렉시컬 스코프가 할당**된다.

### 🆀 내부 함수와 클로저

**🄰** 외부 함수와 마찬가지로, 내부 함수 호출시 **중첩 함수 실행 컨텍스트가 생성**되고 **외부 렉시컬 환경에 대한 참조 값**에 **내부 슬롯에 저장된 외부 함수 렉시컬 환경이 할당**된다. 즉, 내부 슬롯에 저장한 외부 함수 렉시컬 환경은 외부 함수가 종료되어도 참조 가능하다.

이처럼 **생명 주기가 끝난 외부 함수의 변수 참조가 가능한 중첩 함수를 클로저**라 한다. 

### 🆀 클로저는 어떻게 활용할 수 있을까?

**🄰** 의도치 않은 상태 변경 방지 및 은닉, 특정 함수에 변경 허용이 가능하다. 함수형 프로그래밍의 경우, **반환할 함수의 실행 컨텍스트의 렉시컬 환경이 참조되기 때문에 소멸되지 않는다.**

### 🆀 class의 private 필드는 어떨 때 사용할까?

**🄰** 즉시 실행 함수의 클로저로서 사용 가능하지만, 변수 상태가 유지되지 않는데 이를 보완하기 위해 private 필드 정의가 가능해졌다. 

### 🆀 클로저 사용주의

**🄰** `var`키워드 사용시 자유 변수 사용은 가능하지만, `let`으로 보완해야 한다. `let` 키워드 사용시 for문의 코드 블록은 새로운 렉시컬 환경을 사용한다. 블록 반복 실행 종료시 실행중이던 실행 컨텍스트의 렉시컬 환경으로 되돌린다.

---

## 𝐐. 클래스

### 🆀 클래스란 무엇인가?

**🄰**  `class` 키워드를 통해 객체를 생성하는 함수 메커니즘. `new` 연산자와 함께 인스턴스를 생성한다. 메서드에는 **생성자(`constructor`)**, **프로토타입 메서드**, **정적 메서드(`static`)**이 있다. 

### 🆀 클래스의 호이스팅은 어떻게 이뤄지는가?

**🄰** 모든 선언문은 호이스팅 되지만, 클래스는 초기화 없이 선언만 되기 때문에 **선언 이전에 참조 불가**하다. 

### 🆀 클래스의 메서드의 종류는?

**🄰** **constructor** 메서드는 인스턴스를 초기화 하며, 내부 `this`는 생성할 인스턴스의 프로퍼티가 된다. 암묵적으로 `this`와 인스턴스를 반환한다. **prototype**은 기본적인 프로토타입 메서드로, 생성할 인스턴스는 프로토타입 체인의 일원이 된다. **static**은 정적 메서드로 프로토타입 체인상 존재하지 않아 인스턴스 호출 및 상속이 불가하다. 

### 🆀 프로토타입과 정적 메서드의 차이점은 무엇일까?

**🄰** **`this` 바인딩의 차이점**이 존재한다. **프로토타입 메서드** → **생성할 인스턴스 / 정적 메서드** → **호출한 클래스 자신**을 가리킨다. 인스턴스의 프로퍼티 참조시 this와 프로토타입 메서드 사용을 권장하며, 그 이외에는 정적 메서드로 정의하는 것이 좋다. 

### 🆀 클래스 메서드의 특징은?

**🄰** `strict mode` 사용이 가능하다. 프로퍼티 열거 기능 여부는 `false`, `non-constructor`로 `new` 연산자와 함께 호출이 불가.

### 🆀 클래스가 인스턴스를 생성하는 과정

**🄰** `new` 연산자와 함께 호출시 **인스턴스(빈 객체)를 생성 →** 동시에 클래스의 **prototype 프로퍼티가 가리키는 객체로 프로토타입이 설정**된다. 인스턴스는 **`this`에 바인딩** 되어 → **constructor** 실행시 **인스턴스의 초기화 및 반환**이 실행된다.