# 중간 점검 🆀&🄰 (3)

## 𝐐. 프로토타입

### 🆀 객체지향 프로그래밍이란?

**🄰** 객체는 **상태를 나타내는 프로퍼티**, **상태를 조작하는 메서드**를 **하나의 단위로 묶은 복합적인 자료구조**이다. 이러한 **객체의 집합으로 프로그램을 표현**하려는 **프로그래밍 패러다임**이라 할 수 있다.

**자바스크립트는 프로토타입 기반의 객체 지향 프로그래밍 언어**이다. 클래스 기반의 객체 지향 프로그래밍 언어보다, 훨씬 효율적이고 객체지향적인 성향을 띤다.

### 🆀 프로토타입이란?

**🄰** **상속을 구현하며 추상화**를 처리를 통해 중복을 제거합니다. 단 **하나의 메서드를 모든 인스턴스가 공유**하며, 생성자 함수가 생성한 모든 인스턴스는 **자신의 프로토타입, 생성자 함수의 프로토타입의 모든 프로퍼티와 메서드를 상속**받을 수 있습니니다.

여기서 상속은, 프로퍼티와 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 개념을 뜻합니다. 

### 🆀 프로토타입 객체란?

**🄰 객체간의 상속을 구현**하기 위해 사용된다. 상속받는 **하위 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 사용**이 가능하며, 모든 객체는 **`[[prototype]]`** 내부 슬롯을 지닌다. 프로토타입은 객체 생성 방식에 따라 결정되는데, **객체는 하나의 프로토타입**을 지니며 **생성자 함수와 연결**되어 있다. 생성자 함수의 **prototype 프로퍼티**와, 생성자 함수의 프로토타입의 **constructor** 프로퍼티는 **상호 연결**되어 접근이 가능하다.

### 🆀 __proto__ 접근자 프로퍼티는 무엇일까?

**🄰 생성자 함수의 프로토타입이 지닌 프로퍼티**. 자신의 프로토타입의 **`[[Prototype]]` 내부슬롯이 가리키는 프로토타입에 간접적으로 접근**이 가능하다. **단방향으로 구성**되어 **상속만 가능**하게 되어있으며 **프로토타입 체인 생성을 방지**한다. 

### 🆀 생성자 함수 객체의 prototype 프로퍼티는 무엇일까?

**🄰** 함수 객체만이 소유하는 prototype 프로퍼티로, **생성자 함수가 생성할 인스턴스의 prototype을 가리킨다.** 단, 화살표 함수를 비롯한 non-constructor는 프로토타입 생성이 불가하다. 

결국 **__proto__ 접근자 프로퍼티**와, **함수 객체만이 지닌 prototype 프로퍼티**는 사용 목적은 달라도 **동일한 prototype을 가리**키게 된다. 

### 🆀 프로토타입의 constructor 프로퍼티는 무엇일까?

**🄰** **모든 프로토타입은 constructor 프로퍼티**를 지닌다. **자신을 참조하는 생성자 함수를 가리**키며, 해당 연결은 함수 객체가 생성될 때 자동으로 이뤄진다.

---

### 🆀 리터럴(`{}`)로 생성된 객체의 생성자 함수와 프로토타입

**🄰** 리터럴로 생성된 객체도 **프로토타입이 존재**한다. `Object.prototype`을 프로토타입으로 갖는 빈 객체를 생성한다. 단, Object 생성자 함수가 생성한 객체가 아닌 **단순 상속을 위해 프로토타입이 필요**하기 때문에 **가상의 생성자 함수(Object)**를 갖게 되는 것이다. 생성자 함수는 곧 리터럴로 생성된 객체를 생성한 함수라 할 수 있다. 

### 🆀 프로토타입의 생성 시점은?

**🄰** **생성자 함수와 더불어 생성**된다. 프로토타입과 생성자 함수는 **언제나 쌍으로 존재**한다.

사용자 정의 생성자 함수의 경우, 함수 선언문은 런타임 이전에 평가되어 **constructor 함수 객체를 생성하는 시점에 프로토타입이 더불어 생성**(non-constructor X)된다. 오직 constructor 프로퍼티만을 지닌 객체이며, 프로토타입의 prototype은 `Object.prototype`이다. 

빌트인 생성자 함수는 **전역 객체가 생성되는 시점**으로, **빌트인 생성자 함수의 prototype 프로퍼티에 동시에 바인딩** 된다.  

### 🆀 객체 생성 방식에 따른 프로토타입은 어떻게 다를까?

**🄰** 객체 리터럴(`{}`)의 프로토타입은 `Object.prototype`이다. 생성된 객체는 `constructor` / `hasOwnProperty` **메서드가 부재**하지만, **`Object.prototype`에서 상속 받아 사용 가능.** 

Object 생성자 함수의 프로토타입은 `Object.prototype`이다.객체 리터럴과 동일하지만, 프로퍼티 추가하는 방식의 차이점이 존재한다.

생성자 함수의 프로토타입은 생성자 함수에 존재하는 **prototype** **프로퍼티에 바인딩 된 객체**다. 생성된 프로토타입의 프로퍼티는 constructor뿐이며, 프로토타입에 프로퍼티 및 메서드를 추가하여 하위 객체가 상속받을 수 있도록 처리한다.

---

### 🆀 프로토타입 체인이란?

**🄰** 객체에 접근할 **프로퍼티 검색 시,** **내부 슬롯에 바인딩 된 프로토타입으로 이동**하여 **메서드를 서치**하게 되는데 이를 **프로토타입 체인**이라 한다. **`Object.prototype`은 체인의 종점**이며, 상속과 프로퍼티를 위한 일종의 메커니즘이다.

예를 들어 생성자 함수의 경우, 프로토타입이 `Object.prototype` 이기도 하여 `hasOwnProperty` 메서드 호출이 가능하며 프로토타입의 프로토타입은 `Object.prototype` 이다. 

### 🆀 프로토타입 체인과 스코프 체인의 차이점은?

**🄰** 스코프 체인은 **식별자를 검색**하기 위한 메커니즘이며, 프로토타입 체인은 **프로퍼티를 검색**한다는 차이점이 존재한다. 

### 🆀 오버라이딩과 오버 로딩은 무엇일까?

**🄰** 오버라이딩은 상위 클래스가 지닌 메서드를 **하위 클래스가 재정의하여 사용하는 방식**이며, 오버 로딩은 함수의 이름은 동일하나 **매개변수에 의해 메서드를 구별하여 호출**하는 방식이다. 

### 🆀 프로퍼티 섀도잉은 무엇일까?

**🄰** 동일한 이름의 프로퍼티라면 **인스턴스가 우선**이다. **인스턴스 메서드가 프로토타입 메서드를 오버라이딩(하위 클래스가 재정의)함으로써 가려지는 것**을 **프로퍼티 섀도잉**이라 한다. 메서드 또한 **인스턴스가 우선적으로 삭제**된다. **하위 객체로** **`get`**은 가능하지만, **`set`은 프로토타입 프로퍼티에 접근**해야 한다. 

### 🆀 프로토타입은 교체가 가능할까?

**🄰** 생성자 함수 또는 인스턴스를 통해 동적으로 변경 가능하다. 

사용자에 의해 생성된 생성자 함수의 경우, constructor 프로퍼티가 부재함으로 **생성자 함수의 프로토타입에 직접 프로퍼티(consructor)를 추가**한다. → **생성할 인스턴스의 프로토타입이 교체**

인스턴스로 교체할 경우, **__proto__** 접근자 프로퍼티를 통해 가능하다. 즉, **이미 생성된 객체의 프로토타입을 교체**하는 것이다. 

**인스턴스에 의한 프로토타입 교체**는 **constructor 프로퍼티와 연결이 끊어**지게 되어 더이상 **생성자 함수를 가리키게 되지 않게** 된다. 메서드를 통해 프로토타입과 연결 시키거나 직접 교체하기 보다는 **클래스를 통해 직관적인 상속 관계를 구현**하는 것을 권장한다. 

### 🆀 `객체 instanceof 생성자 함수` 연산자는 무엇일까?

**🄰** 프로토타입의 constructor 프로퍼티 → 생성자 함수가 아닌, **생성자 함수의 prototype 프로퍼티 → 바인딩 된 객체가 프로토타입 체인상의 존재 여부를 확인**하는 **연산자**다. **`boolean` 값을 반환**하며, constructor 프로퍼티와 생성자 함수간의 연결보다, **객체가 상속받은 prototype 프로퍼티 → 프로토타입의 연결**이 유지된다면 문제가 없다.

---

### 🆀 프로토타입을 직접 상속하는 방법은 무엇이 있을까?

**🄰** `Object.create()` 메서드 혹은 **__proto__**접근자 프로퍼티로 직접 상속 구현이 가능하다. 

`Object.create(지정할 프토토타입, 생설할 객체의 키와 디스크립터 객체로 이뤄진 객체)`를 통해 명시적으로 프로토타입을 지정하여 객체 생성 후 직접적인 상속 구현이 가능하다. 단, Object.prototype은 모든 프로토타입 체인의 종점이므로, 객체를 생성할 가능성이 존재하여 빌트인 메서드는 간접 호출을 권장한다.

위의 방식보다 **__proto__**접근자 프로퍼티를 통해 간단하고 동일한 직접 상속 구현이 가능하다. 

```jsx
const object = {
	y: 20,
	__proto__: myProto // 프로토타입 상속
}
```

### 🆀 정적 프로퍼티와 메서드는 무엇일까?

**🄰** 별도의 인스턴스 생성 없이 **생성자 함수만으로 참조/호출이 가능한 프로퍼티와 메서드**다. **프로토타입 체인에 속하지 않아, 생성한 인스턴스로 참조/호출이 불가.**

☝️) **`Object.create`**는 __정적 메서드__, **`Object.prototype.hasOwnProperty`**는 생성자 함수의 __프로토타입 메서드__ 이다.

인스턴스 생성 없이도 프로토타입 메서드 호출이 가능하며, 이때 `this`는 **인스턴스를 가리킨다.**

### 🆀 프로퍼티 존재 유무를 어떻게 확인할까?

**🄰** **`key in object`**연산자(프로퍼티 존재 유무를 boolean 값으로 반환)와, **`Reflect.has(object, key)`** 메서드를 통해 확인이 가능하다.

**`Object.prototype.hasOwnProperty(key)`** 메서드를 통해 프로퍼티 존재 유무 확인이 가능하다. **객체 고유의 프로퍼티 키 ⇒ true**, **상속 받는 프로토타입의 프로퍼티 ⇒ false**를 반환한다.

### 🆀 프로퍼티를 열거하는 방법은 무엇이 있을까?

🄰 **`for(key in 객체){key...}`** 문을 통해 객체의 모든 프로퍼티를 순회하며 열거할 수 있다. Symbol이나 toString, Object.prototype은 제외되며 객체의 프로토타입 체인상에 존재하는 프로퍼티 중 [[Enumerable]] 값이 true인 값만 순회하며 열거. 단, 별도로 프로퍼티 존재 유무 추가 확인이 필요하다. 배열은 for, forEach, for…of 메서드를 권장. 

**`Object.keys/values/entires**(obj)` 자신의 프로퍼티인지 추가 확인을 동시에 처리** 해주는 메서드로 **사용이 권장**된다. 순서대로 **열거 가능한 키/값/키와 값의 쌍의** **배열을 담아 반환**한다.

```jsx
Object.entries(person)
	.forEach(([key, value])=>console.log(key, value))
```

### ⇒ 자바스크립트는 프로토타입 기반의 객체지향 프로그래밍 언어이다.

---

### 🆀 strict mode란 무엇일까?

**🄰** **엄격한 문법 체크**로 코드에 대한 **명시적 에러를 발생.** ⑴선언하지 않은 변수를 참조하거나, ⑵delete 연산자로 삭제하거나, ⑶매개변수 이름이 중복되거나, ⑷with문 사용시 에러를 발생. **즉시 실행 함수로 감쓴 스크립트 단위**로 적용.

---

## 𝐐. 빌트인 객체

전역 객체는 **빌트인 객체/호스트 객체/사용자 정의 객체**로 분류된다.

### 🆀 전역 객체는 무엇일까?

**🄰** 코드 실행 이전 단계에서 **자바스크립트 엔진에 의해 먼저 생성되는 특수한 객체**로, 구조상 **표준 빌트인 객체/호스트 객체를 프로퍼티로 소유하는 최상의 객체**이다. 브라우저 환경에서는 window, node.js 환경에서 global이라 표현한다. 

`var` 키워드 사용시 전역 변수 및 함수도 전역 객체의 프로퍼티가 된다. ↔ 블록 레벨 스코프인 `let`과 `const`로 선언한 변수는 전역 객체의 프로퍼티가 될 수 없다.

### 🆀 표준 빌트인 객체란 무엇일까?

**🄰** 자바스크립트는 약 40여개의 표준 빌트인 객체를 제공한다. 

생성자 함수인 표준 빌트인 객체는 프로토타입 메서드, 정적 메서드를 제공하고 생성한 인스턴스의 프로토타입(`생성자함수.prototype`)은 생성자 함수의 **prototype** 프로퍼티에 바인딩 된 객체다. (`String`(생성자 함수)의 **prototype** 프로퍼티 → `생성자 함수.prototype`)

생성자 함수가 아닌 표준 빌트인 객체(Math, Reflect, JSON)는 정적 메서드만 제공.

### 🆀 표준 빌트인 생성자 함수는 왜 존재할까?(원시값과 래퍼객체)

**🄰** **원시값에 객체처럼 접근**할 때, 자바스크립트 엔진은 **원시값을 일시적으로 연관된 객체를 생성**하여 프로퍼티 접근(`str.length`), 혹은 메서드 호출(`str.toUppercase()`) 뒤 원시값으로 되돌린다. 이때 생성되는 임시 객체를 **래퍼 객체**라고 한다.

즉, 표준 빌트인 생성자 함수는 **별다른 인스턴스를 생성할 필요가 없다.**

### 🆀 빌트인 전역 프로퍼티/전역 함수는 무엇인가?

**🄰** 전역 객체의 프로퍼티이다. 무한대를 나타내는 숫자값 **Infinity**, 숫자가 아닌 숫자값 **NaN**, 원시 타입인 **undefined**가 있다. 

전역 함수는 전역에서 호출할 수 있는 전역 객체의 메서드이다. `eval()` (문자열을 인수로 전달하여 값을 생성), `isFinite()` (정상적 유한수를 판별하여 boolean 값 반환), `isNaN()` (NaN을 판별하여 boolean 값 반환), `parseFloat()` (문자열 인수 → 실수로 해석 반환), `parseInt()` (문자열 인수 → 정수로 해석하여 반환), `encode/decodeURI()` (문자열을 이스케이프 처리를 위해 인코딩/인코딩 URI를 디코딩), `encode/decodeURIComponent()` (쿼리 스트링 구분자까지 포함한 URI 구성 요소를 인코딩/디코딩)등이 있다.

### 🆀 암묵적 전역은 어떻게 일어날까?

**🄰** **선언하지 않은 식별자에 값을 할당**하면 **전역 객체의 프로퍼티**가 된다. 예로 `y=20`이 **`window**.y=20` 동적으로 프로퍼티를 생성**하는데, 이를 **암묵적 전역**이라 한다. 단, 전역 객체 프로퍼티일 뿐 **전역 변수가 아니기에 호이스팅이 일어나지 않으며** **`delete`(전역 변수 삭제 불가)로도 삭제**가 가능하다.

---