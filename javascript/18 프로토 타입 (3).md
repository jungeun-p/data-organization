# 18. 프로토 타입 (3)

## ✔️ 프로토타입 체인은 무엇일까?

생성자 함수의 프로토타입은 `Object.prototype`이기도 해서 `hasOwnProperty` 메서드 호출이 가능하다. 즉, 프로토타입의 프로토타입은 언제나 `Object.prototype`이다. 

객체에 **접근할 프로퍼티를 검색**할 때 내부 슬롯에 바인딩 된 프로토타입으로 이동하여 메서드를 서치하기 시작하는데 이를 **프로토타입 체인**이라 한다. **Object.prototype은 체인의 종점**이며, **상속과 프로퍼티를 위한 일종의 메커니즘**이다. 

### ∙스코프 체인과의 차이점은?

**스코프 체인은 식별자를 검색**하기 위한 메커니즘으로, **프로토타입 체인은 프로퍼티를 검색**한다는 점에 차이점이 있다. 

## ✔️ 오버라이딩과 프로퍼티 섀도잉

동일한 이름의 프로퍼티라면 **인스턴스 프로퍼티가 우선**이다. 인스턴스 메서드가 프로토타입 메서드를 **오버라이딩** 함으로써, 가려지는 것을 **프로퍼티 섀도잉**이라고 한다. 삭제의 경우도 인스턴스 메서드가 우선적으로 삭제된다. 하위 객체로 get은 허용되지만, set(추가 및 삭제)의 경우에는 불가하기 때문에 프로토타입 프로퍼티에 직접 접근해야 한다. 

### ∙프로퍼티 섀도잉

상속 관계에 의해 프로퍼티가 가려지는 현상

### ∙오버라이딩

상위 클래스가 지닌 메서드를 하위 클래스가 재정의하여 사용하는 방식.

### ∙오버 로딩

함수의 이름은 동일하나, 매개변수에 의해 메서드를 구별하여 호출하는 방식.

## ✔️ 프로토타입의 교체

프로토타입은 생성자 함수 또는 인스턴스를 통해 동적으로 변경이 가능하다. 

### ∙생성자 함수에 의한 프로토타입 교체

생성자 함수에게는 constructor 프로퍼티가 부재하여, 생성자 함수의 `prototype`에 **직접 프로퍼티를 추가**해주어야 한다. 즉, **생성할 인스턴스의 프로토타입이 교체된다.** 

```jsx
Person.prototype {
	// 프로토타입의 프로퍼티인 constructor는 
	// **생성자 함수를 가리키게 된다.** 
	**constructor**: **Person**,
	sayHello(){}
}
```

### ∙인스턴스에 의한 프로토타입 교체

인스턴스의 **__proto__**접근자 프로퍼티를 통해 교체가 가능하다. 즉, 이미 생성된 객체의 프로토타입을 교체하는 것이다. 

### ∙차이점은 무엇일까?

**인스턴스에 의한 프로토타입 교체**를 할 경우 constructor 프로퍼티와 연결이 끊어지게 되어 더이상 **생성자 함수를 가리키지 않게 된다.** 

⇒ constructor 프로퍼티를 별도로 추가한 후 `setPrototypeOf(a, b)` 메서드를 를 통해 프로토타입과 연결 시켜야 한다. 

⇒ 프로토타입은 직접 교체하기 보다는 ES6 이후 추가된 클래스를 통해 직관적인 상속 관계를 구현하는 것이 좋다. 

## ✔️ `instanceof`연산자

```jsx
객체 instanceof 생성자 함수
```

`prototype`의 constructor 프로퍼티가 가리키는 ~~생성자 함수가 아닌~~, **생성자 함수의 `prototype` 에 바인딩 된 객체**가 **프로토타입 체인 상의 존재 여부를 확인**하는 연산자다. 존재 유무에 따라 `true` or `false`를 반환한다. 고로, **constructor** 프로퍼티와 생성자 함수간의 연결이 파괴되어도, 객체가 상속받은 **prototype** 프로퍼티와 프로토타입의 연결이 유지된다면 문제가 없다.