# 39. 이벤트

이벤트가 발생시 브라우저에게 이벤트 핸들러를 등록하여 함수 호출을 위임하게 된다. 이때 어트리뷰트와 프로퍼티 방식으로 나뉘어진다. 

### ∙어트리뷰트

onClick 속성에 이벤트 **핸들러를 등록하여** 참조가 아닌 **호출을 할당**하여 **암묵적으로 함수를 생성**한다. 프레임워크나 라이브러리에 사용된다.

### ∙프로퍼티

- `addEventListener()`
    
    여러 이벤트 핸들러가 인수로 전달 가능하며, `removeEventListener()` 메서드를 통해 이벤트 삭제도 가능하다. 단, 기존 프로퍼티 방식은 불가.
    
- `event(e)`
    
    이벤트 발생시 이벤트 객체가 생성되어 이벤트 핸들러 첫번째 인수로 전달되는데, `event(e)` 로 암묵적 할당이 이뤄진다. 
    
- `target`
    
    이벤트 객체는 타입에 따라 달라지는데, `target`의 경우 **이벤트를 발생시킨 DOM 요소**를 가리키고 **마우스 정보로 뷰포트 정보** 취득, **키보드 정보로 입력한 키값을 문자열로 반환** 가능하다.
    

## ✔️ 이벤트 전파와 위임

### ∙ 이벤트 전파

이벤트는 DOM트리를 통해 전파되는데, `캡처링 → 타깃 → 버블링` 순서로 나뉜다. 클릭 이벤트 발생시 **window에서 타깃 방향 전파(캡처링)** 후, **타깃에 도달(타깃)**하고 **다시 window 방향으로 전달(버블링)**된다. 

- `addEventListener()`
    
    캡처링도 캐치 가능하며 이벤트 전파를 통해 상위 DOM 요소까지 캐치 가능.
    

### ∙ 이벤트 위임

**상위 DOM에 이벤트 핸들러 등록시 하위 요소로 이벤트가 전달**된다. `matchs()` 메서드로 자식 요소를 판별, `stopPropagation()` 메서드로 이벤트 전파 중단도 가능하다.

## ✔️ this

### ∙ 어트리뷰트

일반 함수로 호출되어 **전역 객체(`window`)에 바인딩** 된다. 이때 전달된 **`this`는 바인딩 된 DOM요소를 가리**키게 된다. 

### ∙ 프로퍼티

`addEventListener()` 등록시 **바인딩 된 DOM, currentTarget을 가리키게 된다.** 이때 **화살표 함수(`()⇒{}`)로 전달시** `**this` 바인딩이 없기 때문에 상위 스코프**를 가리키게 된다.

### ∙ 클래스 내부

**바인딩 된 DOM**을 가리키기 때문에 `bind(this)` 메서드로 바인딩하여 생성할 인스턴스를 가리키도록 처리해야 한다. 

**화살표 함수**(`**()⇒{}**`)사용시 **생성할 인스턴스를 가리**키지만 프로토타입 메서드가 아닌 **인스턴스 메서드**가 된다.

## ✔️ 커스텀 이벤트

`Event()`, `UIEvent()`, `MouseEvent()` 생성자 함수를 통해 이벤트 타입을 인수로 전달하여 커스텀 이벤트 생성이 가능하다. 단, 이벤트 **버블링 처리가 되지 않아 두번째 객체로 `true`값을 전달**하여 프로퍼티 추가도 가능하다. *생성자 함수 커스텀 이벤트의 `isTrusted`는 언제나 `false`

`**dispatchEvent()**` 인수로 이벤트 타입 전달시 이벤트가 동기로 진행. 단, 이벤트 핸들로 등록이 필수. 

```jsx
$button.addEventListener('click', ()=>{});

const customEvent = new MouseEvent('click'); // 마우스 커스텀 이벤트 등록
$button.dispatchEvent(customEvent); // 이벤트 동기로 진행 처리
```

- `CustomEvent()`
    
    임의의 이벤트 타입 전달시 이벤트 핸들러는 `**addEventListener()`를 통해서만 등록이 가능**하다(⇒ `on+타입이름`의 요소 노드가 부재하기 때문). 
    
    두번째 인수로 detail 프로퍼티 객체에 전달 가능(`e.detail`)