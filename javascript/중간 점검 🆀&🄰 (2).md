# 중간 점검 🆀&🄰 (2)

### 🆀 객체란 무엇인가?

**🄰** **다양한 타입의 값(프로퍼티, 메서드)을 하나의 단위로 구성한 자료구조. 0개 이상의 프로퍼티와 메서드로 구성된 집합체. 객체는 프로퍼티와 메서드를 통해 상태와 동작을 하나의 단위로 구조화** 할 수 있다. **변경이 가능(mutable)** 하다. 

자바스크립트는 객체 기반의 언어이며, 자바스크립트를 구성하는 모든 것이 객체이다. 원시값을 제외한 나머지 값(함수, 배열, 정규 표현식)은 모두 객체라 할 수 있다. 

### 🆀 프로퍼티는 무엇인가?

**🄰** **객체의 상태(data)를 나타내는 값.** **`key`와 `value`로 구성**되어 있으며, `key`는 심벌이나 문자열, `value`는 사용 가능한 값이다. **마침표(.)** 나, **대괄호(obj[’key’])** 를 통해 **접근 가능**하며 부재할 경우 `undefined`를 반환한다. 기존에 없던 프로퍼티에 값을 할당하거나, 동적으로 재할당하여 값이 갱신되거나 동적으로 추가할 수 있다. `delete` 연산자를 통해 **프로퍼티 삭제도 가능**하다. 

### 🆀 메서드는 무엇인가?

**🄰** **프로퍼티의 값이 함수인 것**. 프로퍼티를 **참조하고 조작할 수 있는 동작**(behavior)으로 **객체에 묶여있는 함수**다. 

### 🆀 객체는 어떻게 생성할까?

**🄰** 프로토타입 기반의 객체 지향 언어인 자바스크립트에서 객체 생성 방법에는 객체 리터럴, Object 생성자 함수, 생성자 함수, Object.create 메서드, 클래스(ES6) 등이 있다. 

객체 리터럴(`{}`)을 통해 일반적이고 간단하게 생성 가능하다. 코드 블록이 아닌 **값으로 평가되는 표현식**으로, 뒤에 **세미콜론(`;`)이 붙는다.** 프로퍼티 유무에 따라 빈 객체 혹은 포함된 객체를 생성하거나 이후 **동적으로 추가 가능**하다.

### 🆀 ES6의 객체 리터럴 생성 방법은 뭐가 다를까?

**🄰** `key`와 `value`가 동일할 때 **`key`값의 생략이 가능**하다. 계산된 프로퍼티 이름의 **`key`를 동적으로 생성**하거나, **메서드의 경우 `function` 키워드 생략**이 가능하다. 

### 🆀 생성자 함수와 인스턴스는 무엇인가?

**🄰** 클래스 기반의 객체 지향 언어의 경우 **클래스를 정의**한 후 `new` 연산자를 통해 **생성자 함수를 호출**하여 **인스턴스를 생성**하게 되는데, **클래스는 일종의 템플릿**이며 **인스턴스는 클래스로 생성되어 메모리에 저장된 실체**를 의미한다.

---

### 🆀 원시 타입과 객체의 차이점은 무엇인가?

**🄰** 변경 가능의 유무가 다르다. **원시값은 변경이 불가능**하다. 변수에 할당시 **실제값이 저장**되고, **원시값이 복사되어 전달(값에 의한 전달) 된다.** 반면 **객체는 참조값에 의해 실제 객체에 접근**하여 변**경이 가능**하다. 변수 할당시 **참조값이 저장되고 참조값이 복사되어 전달(참조에 의한 전달)된다.** 

### 🆀 “값을 할당”한다는 것은 무엇인가?

**🄰** 값은 변경되지 않고 새로운 **메모리 공간 확보 후 재할당 한 원시값을 가리**킨다. 즉, **메모리 공간의 주소가 변경**되어 전달 후 **값을 참조하는 개념**이다. 원시값은 애초에 변경이 불가하다. `새로운 메모리 공간(변수) 확보 ⇒ 값을 저장 ⇒ 메모리 공간 주소 변경`을 통해 불변성을 지키는 것이다. 

### 🆀 “값에 의한 전달”과 “참조에 의한 전달”의 차이점은 무엇인가?

**🄰** 원시타입과 객체타입은 메모리 공간에 저장된 **값을 복사해서 전달하는 면에서는 동일**하나, **저장 되는 값이(원시값, 참조값)다르다.** 

**원시값**은 값, 즉 **메모리 주소가 전달되어 값을 참조(값에 의한 전달)**한다. 반면 객체는 직접 변경이 가능한데, **참조값이 복사되어 전달(참조에 의한 전달)**되고 메모리 공간 주소는 달라도 **동일한 참조값을 가리**키게 되는 차이가 존재한다.

### 🆀 변수/재할당/참조값

🄰 변수: 메모리 공간 / 재할당: 메모리 주소 전달 / 참조값: 생성된 객체에 저장된 메모리 공간 주소.

---

### 🆀 함수란 무엇일까?

**🄰** 함수는 **블록 내부의 코드를 실행하고 결과를 반환**한다. **재사용**이 가능하며, **객체 타입의 값**이다. 함수는 **함수 객체를 가리키는 식별자로 호출**된다. 함수 선언문, 함수 표현식, Function 생성자 함수, 화살표 함수가 존재한다. 

### 🆀 함수 선언문과 표현식, 화살표 함수의 각각의 특징은 어떨까?

**🄰** **⑴함수 선언문**은 객체 리터럴(`{}`)을 통해 생성이 가능하며, **값이 아닌 문**이기 때문에 함수 객체 생성 및 호출을 위해 **동일한 이름의 식별자를 암묵적으로 생성** 하여 **객체 할당 후 호출**이 가능하다.

**⑵함수 표현식**은 **일급 객체**로서 **값처럼 자유롭게 사용**이 가능하기 때문에 **식별자를 통해 호출**이 가능하다.

**⑶화살표 함수**(`()=>{}`)는 **익명 함수**로 정의된다. 내부 동작과 표현이 **간략화** 되어있다. 생성자 함수로 생성 불가하며 `this` 바인딩 기준이 기존 함수와 다르다. `prototype` 및 `arguments` 객체 생성을 하지 않는다. 

### 🆀 함수는 어떻게 호이스팅 되는 걸까?

**🄰** 함수 선언문과 표현식은 호이스팅 방식이 다르다. 함수 선언문의 경우 동일한 이름의 식별자를 암묵적으로 생성 하고 함수 객체 할당 후 호출이 가능하기 때문에 **선언 이전에 호출이 가능(⇒ 함수 호이스팅)**하다. 반면 함수 표현식의 경우 런타임 이후에 함수 객체 할당이 이뤄져 **선언 이전 접근시 호출이 불가**하다. 그러므로 **함수는 표현식을 권장**하는 편. 

### 🆀 함수 호출은 어떻게 이뤄질까?

**🄰** 함수 호출 → 코드 실행 중단 → 함수 실행으로 흐름을 옮긴다. 함수는 **매개변수(parameter, 인자)를 통해 인수(arguments)를 전달**한다. **매개변수는 함수 내부에서만 참조**(스코프가 함수 내부)하며, 초과된 인수는 무시된다. 함수 **실행 완료시 `return` 키워드 뒤에 오는 표현식을 평가**하여 실행 **결과를 반환**하며, 함수 내부에서만 사용 가능하다. 

### 🆀 함수의 종류

**🄰** 함수에는 **즉시 함수 실행**, **재귀 함수**, **중첩 함수**, **콜백 함수**, **순수 함수**가 존재한다. 

**즉시 함수 실행**은 **정의와 함께 호출**되는 함수로, 재호출이 불가하다. **재귀 함수**는 자기 자신을 호출, 즉 **재귀 호출을 수행하는 함수**로, 반복문 없이 **반복 처리 구현이 가능하며, 탈출 조건을 명시**해야 한다. **중첩 함수**는 **함수 내부에 정의된 내부 함수**로, 외부 함수 내에서만 호출이 가능하며 호이스팅으로 부수효과가 발생할 수 있으니 선언문을 통한 함수 정의는 바람직하지 않다.

**콜백 함수**는 **매개변수를 통해 함수 내부로 전달되는 함수**로, **고차 함수에 의해 호출** 됩니다. **함수 외부에서 정의 후 고차 함수로 전달**하는 게 효율적이며 **비동기 처리**에 활용되는 중요한 패턴입니다.

**고차 함수**는 **함수 외부에서 콜백 함수를 전달 받는 함수.** 함수 자체를 전달 받아 고차 함수 실행시 **콜백을 생성**한다. 배열 고차 함수(map, filter, reduce)가 있습니다. 

### 🆀 함수형 프로그래밍이란 무엇일까?

**🄰** 객체는 변경이 가능하며, 참조에 의해 전달된다. **외부 함수로 인해 원본 객체가 변경되는 부수 효과**가 발생하여 부작용이 생기기 때문에 **반드시 불변으로 관리**해야 한다. 이때 **외부 상태 의존하지 않는 함수를 순수 함수**라고 하며, **부수 효과를 최소화하여 불변성을 지향**하는 프로그래밍을 함수형 프로그래밍 패러다임이다.

---

### 🆀 스코프란 무엇일까?

**🄰** **선언된 위치에 따라 자신을 참조할 수 있는 유효범위**를 뜻한다. 자바스크립트 엔진은 코드 실행시 문맥을 고려하여 식별자를 결정한다. `var`와 `let` & `const` 는 스코프 내에 차이점이 존재하는데, `var` 키워드는 중복 선언이 가능하여 재할당 되지만, `let` & `const` 키워드는 중복 선언을 허용하지 않는다. 

### 🆀 전역 스코프와 지역 스코프의 차이점

**🄰** 코드 바깥 영역인 **전역 스코프**, 함수 몸체 내부인 **지역 스코프**로 나뉘어진다. 변수 또한 마찬가지로, **자신이 정의된 위치에 따라 스코프가 결정**되며 **스코프 체인**을 통해 참조할 변수를 찾는다.

### 🆀 스코프 체인은 무엇일까?

**🄰** 중첩 함수(함수 내부에 정의된 함수)처럼 **지역 스코프도 중첩**이 가능한데, 계층적 구조를 지니게 되며 외부 함수는 내부 함수의 상위 스코프가 된다. 이렇게 **계층적으로 연결되어 실행 컨텍스트의 렉시컬 환경이 단방향으로 연결된 것을 스코프 체인**이며, **상위 → 하위로 탐색**한다. 

### 🆀 실행 컨텍스트와 렉시컬 환경이란?

**🄰** **렉시컬 환경**은 **코드의 문맥**으로, 코드가 어디서 실행되고 어떤 코드가 있는지를 의미한다. **실행 컨텍스트**는 이런 **렉시컬 한경을 구현**한 것을 의미한다. 

자바스크립트는 **실행 컨텍스트를 통해 렉시컬 환경을 구현하며,** 결국 모든 코드는 **실행 컨텍스트에서 평가되고 실행**된다. 결국 스코프는 변수 검색 뿐만 아닌 **식별자를 검색하는 규칙**이라 할 수 있다. 

### 🆀 스코프의 종류는 어떻게 될까(함수 레벨/블록 레벨/렉시컬)?

**🄰** 함수 레벨 스코프는 `var` 키워드 사용시 **함수 코드 블록만 지역 스코프로 사용**되며 블록 내부 선언시 **전역 변수**가 되어 재할당의 부수효과가 일어난다. 

블록 레벨 스코프는 `let`, `const`, `if`, `for`, `while`, `try/catch`의 경우 **블록 레벨 스코프만을 지역 스코프**로 인정한다. 

렉시컬 스코프는 **함수가 정의되는 시점에서 정적으로 결정된 스코프**다. **자신이 정의된 스코프가 곧 상위 스코프**이며, 함수 호출시 **함수가 정의되며 결정된 상위 스코프를 참조**하는 것을 **클로저**라 한다.