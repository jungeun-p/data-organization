# 중간 점검 🆀&🄰 (2)

### 🆀 객체란 무엇인가?

**🄰** **다양한 타입의 값(프로퍼티, 메서드)을 하나의 단위로 구성한 자료구조. 0개 이상의 프로퍼티와 메서드로 구성된 집합체. 객체는 프로퍼티와 메서드를 통해 상태와 동작을 하나의 단위로 구조화** 할 수 있다. **변경이 가능(mutable)** 하다. 

자바스크립트는 객체 기반의 언어이며, 자바스크립트를 구성하는 모든 것이 객체이다. 원시값을 제외한 나머지 값(함수, 배열, 정규 표현식)은 모두 객체라 할 수 있다. 

### 🆀 프로퍼티는 무엇인가?

**🄰** **객체의 상태(data)를 나타내는 값.** **`key`와 `value`로 구성**되어 있으며, `key`는 심벌이나 문자열, `value`는 사용 가능한 값이다. **마침표(.)** 나, **대괄호(obj[’key’])** 를 통해 **접근 가능**하며 부재할 경우 `undefined`를 반환한다. 기존에 없던 프로퍼티에 값을 할당하거나, 동적으로 재할당하여 값이 갱신되거나 동적으로 추가할 수 있다. `delete` 연산자를 통해 **프로퍼티 삭제도 가능**하다. 

### 🆀 메서드는 무엇인가?

**🄰** **프로퍼티의 값이 함수인 것**. 프로퍼티를 **참조하고 조작할 수 있는 동작**(behavior)으로 **객체에 묶여있는 함수**다. 

### 🆀 객체는 어떻게 생성할까?

**🄰** 프로토타입 기반의 객체 지향 언어인 자바스크립트에서 객체 생성 방법에는 객체 리터럴, Object 생성자 함수, 생성자 함수, Object.create 메서드, 클래스(ES6) 등이 있다. 

객체 리터럴(`{}`)을 통해 일반적이고 간단하게 생성 가능하다. 코드 블록이 아닌 **값으로 평가되는 표현식**으로, 뒤에 **세미콜론(`;`)이 붙는다.** 프로퍼티 유무에 따라 빈 객체 혹은 포함된 객체를 생성하거나 이후 **동적으로 추가 가능**하다.

### 🆀 ES6의 객체 리터럴 생성 방법은 뭐가 다를까?

**🄰** `key`와 `value`가 동일할 때 **`key`값의 생략이 가능**하다. 계산된 프로퍼티 이름의 **`key`를 동적으로 생성**하거나, **메서드의 경우 `function` 키워드 생략**이 가능하다. 

### 🆀 생성자 함수와 인스턴스는 무엇인가?

**🄰** 클래스 기반의 객체 지향 언어의 경우 **클래스를 정의**한 후 `new` 연산자를 통해 **생성자 함수를 호출**하여 **인스턴스를 생성**하게 되는데, **클래스는 일종의 템플릿**이며 **인스턴스는 클래스로 생성되어 메모리에 저장된 실체**를 의미한다.

---

### 🆀 원시 타입과 객체의 차이점은 무엇인가?

**🄰** 변경 가능의 유무가 다르다. **원시값은 변경이 불가능**하다. 변수에 할당시 **실제값이 저장**되고, **원시값이 복사되어 전달(값에 의한 전달) 된다.** 반면 **객체는 참조값에 의해 실제 객체에 접근**하여 변**경이 가능**하다. 변수 할당시 **참조값이 저장되고 참조값이 복사되어 전달(참조에 의한 전달)된다.** 

### 🆀 “값을 할당”한다는 것은 무엇인가?

**🄰** 값은 변경되지 않고 새로운 **메모리 공간 확보 후 재할당 한 원시값을 가리**킨다. 즉, **메모리 공간의 주소가 변경**되어 전달 후 **값을 참조하는 개념**이다. 원시값은 애초에 변경이 불가하다. `새로운 메모리 공간(변수) 확보 ⇒ 값을 저장 ⇒ 메모리 공간 주소 변경`을 통해 불변성을 지키는 것이다. 

### 🆀 “값에 의한 전달”과 “참조에 의한 전달”의 차이점은 무엇인가?

**🄰** 원시타입과 객체타입은 메모리 공간에 저장된 **값을 복사해서 전달하는 면에서는 동일**하나, **저장 되는 값이(원시값, 참조값)다르다.** 

**원시값**은 값, 즉 **메모리 주소가 전달되어 값을 참조(값에 의한 전달)**한다. 반면 객체는 직접 변경이 가능한데, **참조값이 복사되어 전달(참조에 의한 전달)**되고 메모리 공간 주소는 달라도 **동일한 참조값을 가리**키게 되는 차이가 존재한다.

### 🆀 변수/재할당/참조값

🄰 변수: 메모리 공간 / 재할당: 메모리 주소 전달 / 참조값: 생성된 객체에 저장된 메모리 공간 주소.

---

### 🆀 함수란 무엇일까?

**🄰** 함수는 **블록 내부의 코드를 실행하고 결과를 반환**한다. **재사용**이 가능하며, **객체 타입의 값**이다. 함수는 **함수 객체를 가리키는 식별자로 호출**된다. 함수 선언문, 함수 표현식, Function 생성자 함수, 화살표 함수가 존재한다. 

### 🆀 함수 선언문과 표현식, 화살표 함수의 각각의 특징은 어떨까?

**🄰** **⑴함수 선언문**은 객체 리터럴(`{}`)을 통해 생성이 가능하며, **값이 아닌 문**이기 때문에 함수 객체 생성 및 호출을 위해 **동일한 이름의 식별자를 암묵적으로 생성** 하여 **객체 할당 후 호출**이 가능하다.

**⑵함수 표현식**은 **일급 객체**로서 **값처럼 자유롭게 사용**이 가능하기 때문에 **식별자를 통해 호출**이 가능하다.

**⑶화살표 함수**(`()=>{}`)는 **익명 함수**로 정의된다. 내부 동작과 표현이 **간략화** 되어있다. 생성자 함수로 생성 불가하며 `this` 바인딩 기준이 기존 함수와 다르다. `prototype` 및 `arguments` 객체 생성을 하지 않는다. 

### 🆀 함수는 어떻게 호이스팅 되는 걸까?

**🄰** 함수 선언문과 표현식은 호이스팅 방식이 다르다. 함수 선언문의 경우 동일한 이름의 식별자를 암묵적으로 생성 하고 함수 객체 할당 후 호출이 가능하기 때문에 **선언 이전에 호출이 가능(⇒ 함수 호이스팅)**하다. 반면 함수 표현식의 경우 런타임 이후에 함수 객체 할당이 이뤄져 **선언 이전 접근시 호출이 불가**하다. 그러므로 **함수는 표현식을 권장**하는 편. 

### 🆀 함수 호출은 어떻게 이뤄질까?

**🄰** 함수 호출 → 코드 실행 중단 → 함수 실행으로 흐름을 옮긴다. 함수는 **매개변수(parameter, 인자)를 통해 인수(arguments)를 전달**한다. **매개변수는 함수 내부에서만 참조**(스코프가 함수 내부)하며, 초과된 인수는 무시된다. 함수 **실행 완료시 `return` 키워드 뒤에 오는 표현식을 평가**하여 실행 **결과를 반환**하며, 함수 내부에서만 사용 가능하다. 

### 🆀 함수의 종류

**🄰** 함수에는 **즉시 함수 실행**, **재귀 함수**, **중첩 함수**, **콜백 함수**, **순수 함수**가 존재한다. 

**즉시 함수 실행**은 **정의와 함께 호출**되는 함수로, 재호출이 불가하다. **재귀 함수**는 자기 자신을 호출, 즉 **재귀 호출을 수행하는 함수**로, 반복문 없이 **반복 처리 구현이 가능하며, 탈출 조건을 명시**해야 한다. **중첩 함수**는 **함수 내부에 정의된 내부 함수**로, 외부 함수 내에서만 호출이 가능하며 호이스팅으로 부수효과가 발생할 수 있으니 선언문을 통한 함수 정의는 바람직하지 않다.

**콜백 함수**는 **매개변수를 통해 함수 내부로 전달되는 함수**로, **고차 함수에 의해 호출** 됩니다. **함수 외부에서 정의 후 고차 함수로 전달**하는 게 효율적이며 **비동기 처리**에 활용되는 중요한 패턴입니다.

**고차 함수**는 **함수 외부에서 콜백 함수를 전달 받는 함수.** 함수 자체를 전달 받아 고차 함수 실행시 **콜백을 생성**한다. 배열 고차 함수(map, filter, reduce)가 있습니다. 

### 🆀 함수형 프로그래밍이란 무엇일까?

**🄰** 객체는 변경이 가능하며, 참조에 의해 전달된다. **외부 함수로 인해 원본 객체가 변경되는 부수 효과**가 발생하여 부작용이 생기기 때문에 **반드시 불변으로 관리**해야 한다. 이때 **외부 상태 의존하지 않는 함수를 순수 함수**라고 하며, **부수 효과를 최소화하여 불변성을 지향**하는 프로그래밍을 함수형 프로그래밍 패러다임이다.

---

### 🆀 스코프란 무엇일까?

**🄰** **선언된 위치에 따라 자신을 참조할 수 있는 유효범위**를 뜻한다. 자바스크립트 엔진은 코드 실행시 문맥을 고려하여 식별자를 결정한다. `var`와 `let` & `const` 는 스코프 내에 차이점이 존재하는데, `var` 키워드는 중복 선언이 가능하여 재할당 되지만, `let` & `const` 키워드는 중복 선언을 허용하지 않는다. 

### 🆀 전역 스코프와 지역 스코프의 차이점

**🄰** 코드 바깥 영역인 **전역 스코프**, 함수 몸체 내부인 **지역 스코프**로 나뉘어진다. 변수 또한 마찬가지로, **자신이 정의된 위치에 따라 스코프가 결정**되며 **스코프 체인**을 통해 참조할 변수를 찾는다.

### 🆀 스코프 체인은 무엇일까?

**🄰** 중첩 함수(함수 내부에 정의된 함수)처럼 **지역 스코프도 중첩**이 가능한데, 계층적 구조를 지니게 되며 외부 함수는 내부 함수의 상위 스코프가 된다. 이렇게 **계층적으로 연결되어 실행 컨텍스트의 렉시컬 환경이 단방향으로 연결된 것을 스코프 체인**이며, **상위 → 하위로 탐색**한다. 

### 🆀 실행 컨텍스트와 렉시컬 환경이란?

**🄰** **렉시컬 환경**은 **코드의 문맥**으로, 코드가 어디서 실행되고 어떤 코드가 있는지를 의미한다. **실행 컨텍스트**는 이런 **렉시컬 한경을 구현**한 것을 의미한다. 

자바스크립트는 **실행 컨텍스트를 통해 렉시컬 환경을 구현하며,** 결국 모든 코드는 **실행 컨텍스트에서 평가되고 실행**된다. 결국 스코프는 변수 검색 뿐만 아닌 **식별자를 검색하는 규칙**이라 할 수 있다. 

### 🆀 스코프의 종류는 어떻게 될까(함수 레벨/블록 레벨/렉시컬)?

**🄰** 함수 레벨 스코프는 `var` 키워드 사용시 **함수 코드 블록만 지역 스코프로 사용**되며 블록 내부 선언시 **전역 변수**가 되어 재할당의 부수효과가 일어난다. 

블록 레벨 스코프는 `let`, `const`, `if`, `for`, `while`, `try/catch`의 경우 **블록 레벨 스코프만을 지역 스코프**로 인정한다. 

렉시컬 스코프는 **함수가 정의되는 시점에서 정적으로 결정된 스코프**다. **자신이 정의된 스코프가 곧 상위 스코프**이며, 함수 호출시 **함수가 정의되며 결정된 상위 스코프를 참조**하는 것을 **클로저**라 한다.

---

### 🆀 전역 변수 문제점(`var` 키워드)은 무엇일까?

**🄰** 전역 변수의 경우 `var` 키워드로 선언시 ****문제점은 

⑴ **중복 선언이 허용**되어 **재할당의 우려**

⑵ **함수 레벨 스코프**라 함수 외부에서 블록 내부로 선언되어도 **전역 변수**

⑶ **런타임 이전에 선언과 초기화가 동시에 진행**되어 **변수 선언 이전에 참조가 가능**(undefined) → **호이스팅**

⑷ **전역 객체의 프로퍼티(window)가 되며, 암묵적으로 최상위 스코프(전역 스코프)**가 되어 검색 속도도 느려진다.

***전역 객체**는 코드 실행 이전 단계에서 자바스크립트 엔진에 의해 먼저 생성되는 특수한 객체로, 클라이언트(`window`), node.js(`global`)객체가 따로 존재한다. 

⇒ **전역 변수 사용은 자제**하거나, **지역 스코프 또한 좁게** 사용해야 한다.

### 🆀 `let` & `const`의 블록 레벨 스코프

**🄰** 위의 `var` 키워드 문제점을 보완하기 위해 사용된다. 

**`let`** 중복 선언 금지, 블록 레벨 스코프 선언시 지역 변수, 함수 내에 블록 스코프에 중첩, 전역 객체는 블록 내에서만 존재하며 재할당이 가능.

**`const`** 상수 선언시 사용, 블록 레벨 스코프, 객체의 값은 변경 가능, 재할당 금지, 선언과 초기화를 동시에 처리.

### 🆀 `let`과 `const`는 호이스팅이 일어나지 않는 걸까?

**🄰** 런타임 이전에 렉시컬 환경에서 선언만 실행될 뿐, 선언 이전 참조가 불가하여 호이스팅이 일어나지 않는 것처럼 동작(참조 에러) → **TDZ**하는 것이다. 선언문 도달시 초기화가 동시에 진행된다.

---

### 🆀 프로퍼티란 무엇일까?

**🄰** **프로퍼티 어트리뷰트를 명시적으로 정의하거나 재정의** 하는 것. `Object.defineProperty()` 메서드를 통해 정의가 가능하다. 

### 🆀 프로퍼티 어트리뷰트는 무엇일까?

**🄰** **프로퍼티의 상태를 정의하는 내부 슬롯(데이터 프로퍼티), 내부 메서드(접근자 프로퍼티)를 뜻한다.**  `Object.getOwnPropertyDescriptor()`(프로퍼티 디스크립터 객체 반환) 메서드를 통해 **간접 접근**이 가능하다. 데이터 & 접근자 프로퍼티가 존재한다. 

데이터 프로퍼티는 **`key`, `value`로 구성된 일반적인 프로퍼티**이고, 접근자 프로퍼티는 **데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수**이다. 

### 🆀 내부 슬롯과 내부 메서드는 무엇일까?

**🄰** **ECMAScript 사양에 등장하는 `[[]]` 감싼 이름들을 내부 슬롯과 내부 메서드**라고 한다. 모든 객체는 **`[[Prototype]]`이라는 내부 슬롯**을 지니며, 접근자 함수인 **__proto__**(**내부 메서드**)를 통해 **간접 접근**이 가능하다.

---

### 🆀 생성자 함수란?

**🄰** **`new` 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수.** 템플릿처럼 **동일한 프로퍼티 객체를 간편하게 생성할** 수 있고, 다양한 **빌트인 생성자 함수가 존재**한다. Object 생성자 함수의 경우, 빈 객체(인스턴스)를 생성한다. 일반 함수도 생성자 함수로 정의 후 `new` 연산자와 호출시 생성자 함수처럼 동작할 수 있다. 

### 🆀 `this` 바인딩은 어떻게 될까?

**🄰** **함수 호출 방식**에 따라 **동적으로 결정**된다. 일반 함수는 **전역 객체**를 가리키고, 메서드로서의 호출은 **자신을 호출한 객체**를 가리키고, 생성자 함수는 **자신이 생성할 인스턴스**를 가리킨다. 

### 🆀 생성자 함수로 인스턴스는 어떻게 생성될까?

**🄰** 자바스크립트 엔진에 의해 **암묵적으로 빈 객체(인스턴스)를 생성**하여 **`this` 바인딩 처리**를 한다. 이후 **생성할 인스턴스를 가리키**게 되고, 인스턴스에 프로퍼티 및 메서드를 추가하여 **인수로 전달받은 값을 할당 후 초기화** 한다. 이후 **바인딩 된 `this`를 반환**한다. 

### 🆀 constructor와 non-constructor의 차이점은 무엇일까?

**🄰** 함수 객체는 **`[[Call]]`**, new 연산자의 생성자 함수는 **`[[Construct]]`** 내부 슬롯을 지니고 있다. 함수 객체는 **constructor(함수 선언문, 표현식, 클래스)** 또는 **non-constructor(메서드, 화살표 함수)**이며 **함수 정의 방식에 따라 구분**한다. 

### 🆀 `new` 연산자 키워드란?

**🄰** 해당 키워드를 통해 생성자 함수로 동작하게 되며 **`[[Construct]]`가 호출**된다. 생성자 함수로서 호출시 `this`는 생성할 인스턴스를 가리키게 된다. **`new.target`을 통해 `new` 생성자 함수로서의 호출 감별**이 가능하다. 생성자 함수 호출시 함수 자신, 일반 함수는 undefined를 반환하며 프로토타입에 의해 생성자 함수와 연결된다.

---

### 🆀 일급 객체의 기준은 어떻게 될까?

**🄰** **⑴무명의 리터럴**로 생성될 것. **⑵변수나 자료구조에 저장**될 것. **⑶함수 매개변수로 전달 및 반환값**으로 사용될 것. **자바스크립트**는 위의 기준을 만족하므로, **일급 객체**라 할 수 있다. 함수 또한 매개변수에 전달 및 반환값을 사용하고, 호출이 가능하며, 함수 고유의 프로퍼티를 소유하므로 **함수도 일급 객체**다. 

### 🆀 함수 객체의 프로퍼티는 무엇이 있을까?

**🄰** **함수는 객체이기 때문에 프로퍼티**를 지닌다. `Object.getOwnPropertyDescriptors()` 메서드를 통해 확인 가능하다.

- **arguments** 전달된 인수들의 정보를 담고 있는 **유사 배열 객체.** 유사 배열 객체란, `length`프로퍼티를 가진 객체로, for문을 순회할 수 있는 **배열이 아닌 객체**다. `key`는 **인수의 순서**, `value`는 **인수**를 갖고 있다(`arguments[i]`).
- **length** 선언한 매개변수(parameter)의 개수를 가리킨다.
- **name**  함수의 이름을 나타내며, 익명 함수는 함수 객체를 가리키는 식별자를 값으로 지닌다(ES6)

### 🆀 __proto__와, `prototype` 프로퍼티는 무엇일까?

🄰 **__proto__**는 `[[Prototype]]` 내부슬롯이 가리키는 **프로토타입 객체에 접근하기 위한 접근자 프로퍼티**다. 내부 슬롯은 직접 접근이 불가하여, 객체에 간접적으로 접근이 가능하다. **`prototype` 프로퍼티**는 생성자 함수로 호출할 수 있는 함수 객체, 즉 **constructor만이 소유하는 프로퍼티**로 **생성할 인스턴스의 프로토타입 객체를 가리키게** 된다.